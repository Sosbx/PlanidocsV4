<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nettoyage Service Worker - Planidocs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .button {
            background-color: #3b82f6;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            display: inline-block;
        }
        .button:hover {
            background-color: #2563eb;
        }
        .button.danger {
            background-color: #ef4444;
        }
        .button.danger:hover {
            background-color: #dc2626;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ†Ô∏è Nettoyage Service Worker</h1>
        <p>Cette page permet de nettoyer les Service Workers probl√©matiques de Planidocs.</p>
        
        <div>
            <button class="button" onclick="checkStatus()">üìä V√©rifier l'√©tat</button>
            <button class="button danger" onclick="cleanupAll()">üßπ Nettoyage complet</button>
            <button class="button" onclick="registerSimple()">üì¶ Installer SW Simple</button>
            <button class="button" onclick="clearLogs()">üóëÔ∏è Vider les logs</button>
        </div>
        
        <div id="status"></div>
        <div class="log" id="logs">Pr√™t pour le nettoyage...\n</div>
    </div>

    <script>
        function log(message) {
            const logs = document.getElementById('logs');
            logs.textContent += new Date().toLocaleTimeString() + ' - ' + message + '\n';
            logs.scrollTop = logs.scrollHeight;
        }

        function setStatus(message, type = 'success') {
            const status = document.getElementById('status');
            status.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        async function checkStatus() {
            log('üîç V√©rification de l\'√©tat des Service Workers...');
            
            if (!('serviceWorker' in navigator)) {
                setStatus('‚ùå Service Worker non support√©', 'error');
                log('‚ùå Service Worker non support√© par ce navigateur');
                return;
            }

            try {
                const registrations = await navigator.serviceWorker.getRegistrations();
                log(`üìã ${registrations.length} Service Worker(s) trouv√©(s)`);
                
                registrations.forEach((reg, index) => {
                    log(`  ${index + 1}. Scope: ${reg.scope}`);
                    log(`     √âtat: ${reg.active ? 'Actif' : 'Inactif'}`);
                });

                const cacheNames = await caches.keys();
                log(`üíæ ${cacheNames.length} cache(s) trouv√©(s)`);
                cacheNames.forEach(name => log(`  - ${name}`));

                setStatus(`‚úÖ √âtat v√©rifi√©: ${registrations.length} SW, ${cacheNames.length} caches`);
            } catch (error) {
                log(`‚ùå Erreur: ${error.message}`);
                setStatus('‚ùå Erreur lors de la v√©rification', 'error');
            }
        }

        async function cleanupAll() {
            log('üßπ D√©but du nettoyage complet...');

            if (!('serviceWorker' in navigator)) {
                setStatus('‚ùå Service Worker non support√©', 'error');
                return;
            }

            try {
                // D√©sinscrire tous les Service Workers
                const registrations = await navigator.serviceWorker.getRegistrations();
                log(`üóëÔ∏è D√©sinscription de ${registrations.length} Service Worker(s)...`);
                
                await Promise.all(
                    registrations.map(async registration => {
                        log(`  D√©sinscription: ${registration.scope}`);
                        return registration.unregister();
                    })
                );

                // Vider tous les caches
                const cacheNames = await caches.keys();
                log(`üóëÔ∏è Suppression de ${cacheNames.length} cache(s)...`);
                
                await Promise.all(
                    cacheNames.map(async cacheName => {
                        log(`  Suppression cache: ${cacheName}`);
                        return caches.delete(cacheName);
                    })
                );

                log('‚úÖ Nettoyage complet termin√©!');
                setStatus('‚úÖ Nettoyage complet r√©ussi');
                
            } catch (error) {
                log(`‚ùå Erreur lors du nettoyage: ${error.message}`);
                setStatus('‚ùå Erreur lors du nettoyage', 'error');
            }
        }

        async function registerSimple() {
            log('üì¶ Enregistrement du Service Worker simple...');

            if (!('serviceWorker' in navigator)) {
                setStatus('‚ùå Service Worker non support√©', 'error');
                return;
            }

            try {
                const registration = await navigator.serviceWorker.register('/sw-simple.js', {
                    scope: '/',
                    updateViaCache: 'none'
                });

                log('‚úÖ Service Worker simple enregistr√© avec succ√®s!');
                log(`   Scope: ${registration.scope}`);
                setStatus('‚úÖ Service Worker simple install√©');

                // Forcer l'activation
                if (registration.waiting) {
                    registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                    log('‚ö° Activation forc√©e');
                }

            } catch (error) {
                log(`‚ùå Erreur lors de l'enregistrement: ${error.message}`);
                setStatus('‚ùå Erreur lors de l\'installation', 'error');
            }
        }

        function clearLogs() {
            document.getElementById('logs').textContent = 'Logs vid√©s...\n';
            document.getElementById('status').innerHTML = '';
        }

        // Auto-v√©rification au chargement
        window.addEventListener('load', () => {
            log('üöÄ Page de nettoyage charg√©e');
            checkStatus();
        });
    </script>
</body>
</html>